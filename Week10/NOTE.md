毕业总结

    一、学习方法
        1、五（N）毒神掌，刻意练习法：
            对于普通智商的人，在研究特别难的问题时，初步可以不求理解吃透，以熟练度为主。同步多遍的练习，每一遍都有相应的收获，随着边数的增多，
            问题自然而然的就理解了；
        2、 不要死磕：不论是在校生还是已经工作的社畜，时间都是非常宝贵的，特别是社畜。所以对于自己一时难以理解的问题，千万不能耗费大量时间死磕，
            而是先求对问题熟练，达到师夷长技以制夷的目的；
            
    二、数据结构
        1、一维数据结构：
            1）数组 Array
            2）链表 LinkedList
            
            3）栈 stack (一般由链表来实现，也可以由数组来实现)
            4）队列 Queue
            5）双端队列 Deque (double end queue)
            6）集合 Set
            7）映射 Map
            
        2、二维数据结构
            1）树 tree
            2）图 graph 有向图  无向图 权重
            
            3）二叉搜索树 （binary search tree: AVL 红黑树）
            4）堆 (heap) 最大顶堆 最小顶堆
            5）字典树 （Trie）构建查询关键字的索引字典库
            6）并查集 （disjoint set） 印象不深，不熟悉
            
        3、特殊数据结构
            1）位运算符
            2）布隆过滤器 （使用二进制位来确定一个数据是不是百分百不存在，或者有可能存在）
            3）LRU cache (通过简单修改了Java中的LinkedList源码，来实现)
            
    三、算法总结
        1、暴力算法（不推荐）
            1）所有的问题理论上都可以使用暴力算法解决，前提是不考虑时间复杂度和空间复杂度；
            2）通过分支（if else  OR switch）来区分不同的情况；
            3）通过使用重复计算来解决问题（for循环  OR  while循环）；
            
        2、递归
            1）通过数学归纳法，找到递归方程，将每一层梦境的问题通过不断的调用自身函数，来解决每一层的问题。然后逐层返回，直到达到最上层梦境，
               解决所有的计算，返回最终结果；《盗梦空间》
            2）递归的Java代码模板
                `public void recursion(){
                    //找到边界条件，用以返回上一层递归梦境（防止出现无法跳出递归的情况，导致栈内存溢出stackOverFlow）
                    if ( 条件 ) {
                        return   ;
                    }
                    
                    //处理当前层的逻辑
                    dulCurrentLogic();
                    
                    //调用自身函数，进行递归下探的下层梦境，可以通过传递参数，实现不同梦境的通信
                    recursion();
                    
                    //处理当前层数据，有些容器需要每一层都要是新的（空的），所以在执行完当前层计算后，清空数据
                    deleteCurrentData();
                }`
             
        3、搜索（Search）
            1）DFS（深度优先搜索）：从根节点开始，直到找到叶子节点，然后再向上返回。通过子树的根找到其他的叶子节点，以达到遍历所有节点的目的；
               代表算法思想：回溯思想。在进行回溯时，还可以通过剪枝优化。或者在每一个回溯取最优解，引申出贪心算法，即每一步都获取最优解；
               
            2）BFS（广度优先算法）：从根节点开始，逐层遍历每一个子节点，直到遍历完成所有的节点；
            
            3）A*算法：一般是在地图中获取最优路径，可以使用双端BFS来实现（使用曼哈顿距离来进行计算）；
            
        4、动态规划
            1）获取最优子问题；
            2）定义存储中间状态的容器
            3）推导出动态规划方程；
            
        5、查找
            1）线性结构查找
            
            2）树结构查找
            
            3）散列表查找
            
        6、字符串匹配
            1）朴素匹配（暴力匹配）：一个一个的进行循环对比
            
            2）RK ：将字符串通过哈希函数转换成哈希值，通过哈希值进行比较（由于存在哈希冲突，在哈希值相同时，还要进行朴素匹配）
            
            3）BM：坏字符算法和好后缀算法的合体。保证模式串（子串），每次可以向右移动最大的距离，减少不必要的匹配判断；
            
            4）KMP：通过实现前缀表，来决定向右移动的位置，也是为了减少不必要的匹配判断
            
        7、位运算 （位运算公式）
            1）将X最右边的N位清零：x & (~ 0 << n);
            
            2）获取x的第n位的值（0或者1）：（x>>n）& 1
            
            3）获取x的第n位的幂值：x & (1 << n);
            
            4) 仅将第n位置 置为1：x | (1 << n);
            
            5) 仅将第n位置 置为0：x & (~(1<<n));
            
            6) 将x最高位至第n位（包含第n位）清零：x & ((1 << n) - 1);
            
    三、排序算法
        1、时间复杂度为O(n^2)
            1) 冒泡排序
            
            2）选择排序
            
            3）插入排序
            
            4）希尔排序
            
        2、时间复杂度为O（nlogn）
            1) 归并排序
            
            2）快速排序
            
            3）堆排序
            
        3、时间复杂度为O（n）限制条件非常多，必须是数字
            1）基数排序
            
            2）计数排序
            
            3）桶排序
            
            
            
         
            
                  
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            