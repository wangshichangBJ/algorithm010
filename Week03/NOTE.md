## **一、递归**
    1、递归的易理解描述
        可以把递归的每一层级形象的比喻成《盗梦空间》电影中，每一次层的梦境世界，从真实世界->第一层梦境世界->第二层梦境世界->...->第n层梦境世界；
        在完成第n层梦境世界的任务后->第n-1层梦境世界->...->第一层梦境世界->现实世界；
        1)向下进入到另一个梦境，向上回到原来的梦境；
        2)通过声音同步回到上一层梦境（同样的跳出当前递归的条件）
        3）每一层梦境的环境和不相关的路人都是一份拷贝，只有主角在穿越不同层级的梦境（只有主角发生变化，且通过参数携带着每一层梦境的收获）
    2、递归的内存空间
        递归都是在一层一层的调用函数方法，即所有的递归其实都是在使用栈空间，没执行一次递归就会压一次栈，直到执行完最深层次的递归，结束压栈。
        将栈顶的计算结果向上传递（第n-1层梦境）并出栈（跳出第n层梦境），执行（n-1层梦境）函数，返回到第n-2层递归并出栈，直到所有函数都出栈；
        由于栈的内存是有限的，所以若递归的深度太深（梦境太多），就会导致在有限的空间中不能叠加这么多个函数（梦境），栈内存就会溢出（空间被撑爆）；
    3、递归的Java模板
        /**
        * Java递归模板
        * param level 递归层级（梦境的层级）
        * param param 不同层级递归携带的参数
        */
        public void recur(int level, int param){
  			//1、跳出当前递归的条件
  			if(level > maxLevel){
              //处理结果并返回上一级递归
              process_result
              return;
            }
  
  			//2、处理当前层级逻辑（当前梦境的任务）
  			    process_cur_level(level,param)
              
            //3、下探到下一次递归（跳到更深一层梦境）
            recur(level+1,newParam)
              
            //4、存在公共变量时，当前层级处理掉（清空当前梦境的垃圾，以防止从下一级回来时，产生干扰），不存在共享变量时，可以不处理此步
		}
		4、递归的思维要点
      1）不要进行人肉递归（人脑不善于多层次的数据处理），可以少量的在纸上画递归树；
      2）找到最近最简的方法，将其拆解成可重复解决的问题（重复子问题）；
      3）数据归纳法，推导递推公式，找出n成立时的公式；
      
## **二、分治和回溯**
   1、分治算法：讲一个问题拆分成多个重复的子问题，使用递归的方法求解各个子问题，然后把每个子问题的结果合并统一返回；
   
   2、分治的Java代码模板：
      	public void divide_conquer(problem,param1,param2,...){
      		//1.终止条件
      		//2.处理当前层的逻辑，拆分子问题
      		//3.递归下探到下一层，解决拆分后的子问题
      		//4.将得到的子结果进行合并，然后返回发哦上一层
      		//5.处理当前层的共享变量
    	}
    		
	3、回溯算法是一个不断试错的过程，出现错误就退回，重新安排策略。若没有出错，就继续向下走；（就像走迷宫一样，当前这条路走不通或者死路时，就退回到上一个差路口，选择其他的路径走。若该叉路口都走不通，就在退回到上上个差路口，一步一步的尝试走出迷宫。最差的情况就是吧所有的路径都走一遍）
      