/**
 * @author ShiChang Wang
 * @description 使用位运算解决N皇后
 * @date 2020/7/27
 */
public class TotalNQueens {

    int count = 0;
    public int totalNQueue(int n) {
        if (n < 1) {
            return n;
        }
        //int类型只能表示最大值为32*32的棋盘，如果大于32，则要使用long型
        DFS(0,0,0,0,n);
        return count;
    }

    /**
     * 使用DFS方法递归获取每一行可以放置皇后的位置
     * row:表示棋盘的行，最大值为n
     * col:表示棋盘的列。col的int值的右n位用来表示棋盘的列，若某一位二进制数为0(不能放置皇后)，若为1(可以放置皇后)
     * pie：表示棋盘的左斜列。pie的int值的右n位用来表示棋盘的列，若某一位二进制数为0(不能放置皇后)，若为1(可以放置皇后)
     * na:表示棋盘的右斜列。na的int值的右n位用来表示棋盘的列，若某一位二进制数为0(不能放置皇后)，若为1(可以放置皇后)
     * n：表示棋盘是n*n的棋盘
     */
    private void DFS(int row, int col, int pie, int na, int n) {
        //当棋盘的行数累加到n时，就表示所有的行都已走完，获取到一种放置皇后的方法，count加1记录
        if (row >= n) {
            count++;
            return;
        }
        // 当前行可以放置皇后的位置（右n位有几个1存在，就表示有几个可以放置皇后的位置。0表示不能放置）
        // (col | pie | na):表示第一行所有的位置都为0（后续根据计算值获取）。使用 ~ 取反后，棋盘所有的位置都为1，
        // 棋盘第一行所有的位置都可以放置皇后
        // (1 >> n) - 1：将1的二进制左移n位，经过减1后，就将32-n位全部置为0，n为全部置为1；
        // 由于只需要后n位就可以表示棋盘的一行，所以进行 & 运算，就可以保证除了右n位，其余位都为0；
        int poss = (~(col | pie | na)) & ((1 << n) - 1);
        // poss不为0，表示poss中存在二进制位为1的，即存在可以放置皇后的位置
        while (poss != 0) {
            //获取二进制位中最右边的1，将皇后放在该位置
            int pos = poss & (-poss);
            //递归每一行，处理皇后第一行在pos位置时，从第2行到第n行的皇后的摆放位置
            //na要进行无符号的右移1位。是因为如果皇后在最高的32位时，会报错
            DFS(row + 1, col | pos, (pie | pos) << 1, (na | pos) >>> 1, n);
            //清除二进制位中最右边的1
            poss = poss & (poss - 1);
        }
    }

}
